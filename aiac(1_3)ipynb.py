# -*- coding: utf-8 -*-
"""AIAC(1.3)ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10zJ3OI_iYwY7wGLIIebTW-YbB8olI-oA
"""



import collections
import re

# Define the filename to read from
file_name = 'sample.txt'

# Initialize a dictionary to store word counts
word_counts = collections.Counter()

try:
    # Open the file in read mode ('r')
    with open(file_name, 'r') as file:
        # Read the entire content of the file
        text = file.read()

        # Convert text to lowercase to treat 'The' and 'the' as the same word
        text = text.lower()

        # Remove punctuation and split the text into words
        # re.findall(r'\b\w+\b', text) finds all sequences of word characters
        words = re.findall(r'\b\w+\b', text)

        # Count the frequency of each word
        word_counts.update(words)

    print(f"Word frequencies in '{file_name}':")
    # Display the word frequencies
    for word, count in word_counts.most_common():
        print(f"'{word}': {count}")

except FileNotFoundError:
    print(f"Error: The file '{file_name}' was not found.")
except Exception as e:
    print(f"An error occurred: {e}")

"""### Explanation of the Code:

This program performs the following steps:

1.  **Imports necessary modules**: `collections` (specifically `Counter` for easy word counting) and `re` (for regular expressions to clean text).

2.  **Sets the filename**: It specifies `sample.txt` as the file to be processed.

3.  **Initializes a `Counter`**: `word_counts = collections.Counter()` creates a special type of dictionary that makes counting items very simple.

4.  **Opens and Reads the File**: The `with open(file_name, 'r') as file:` line safely opens `sample.txt` for reading. If the file doesn't exist, it will print an error message.

5.  **Processes the Text**:
    *   `text = file.read()`: Reads the entire content of the file into a single string.
    *   `text = text.lower()`: Converts all the text to lowercase. This ensures that 'The' and 'the' are counted as the same word.
    *   `words = re.findall('\b\w+\b', text)`: This is where punctuation is removed and the text is split into individual words. It looks for sequences of letters and numbers (`\w+`) that are whole words (`\b` for word boundaries).

6.  **Counts Word Frequencies**: `word_counts.update(words)` adds all the words from the `words` list to the `Counter`, automatically counting how many times each word appears.

7.  **Displays Results**: It then prints a header and loops through the `word_counts.most_common()` (which gives words sorted by frequency from highest to lowest) to display each word and its corresponding count.
"""

import pandas as pd

# Define the path to your CSV file
csv_file_path = '/content/instagram_usage_lifestyle.csv'  # <--- IMPORTANT: Replace with your CSV file name

# Define the name of the numeric column you want to analyze
column_to_analyze = 'age' # <--- IMPORTANT: Replace with your numeric column name

try:
    # Read the CSV file into a pandas DataFrame
    df = pd.read_csv(csv_file_path)

    # Display the first few rows to confirm it loaded correctly
    print("First 5 rows of the DataFrame:")
    display(df.head())
    print("\n")

    # Check if the specified column exists in the DataFrame
    if column_to_analyze not in df.columns:
        print(f"Error: Column '{column_to_analyze}' not found in the CSV file.")
    else:
        # Ensure the column is numeric (attempt to convert if not already)
        # 'coerce' will turn non-convertible values into NaN (Not a Number)
        df[column_to_analyze] = pd.to_numeric(df[column_to_analyze], errors='coerce')

        # Drop rows where the column_to_analyze became NaN after conversion
        df_clean = df.dropna(subset=[column_to_analyze])

        if df_clean.empty:
            print(f"Error: Column '{column_to_analyze}' contains no valid numeric data after cleaning.")
        else:
            # Calculate the mean, minimum, and maximum values
            mean_value = df_clean[column_to_analyze].mean()
            min_value = df_clean[column_to_analyze].min()
            max_value = df_clean[column_to_analyze].max()

            # Display the results
            print(f"Statistics for column '{column_to_analyze}':")
            print(f"  Mean: {mean_value:.2f}")
            print(f"  Minimum: {min_value:.2f}")
            print(f"  Maximum: {max_value:.2f}")

except FileNotFoundError:
    print(f"Error: The file '{csv_file_path}' was not found. Please check the path.")
except Exception as e:
    print(f"An unexpected error occurred: {e}")

def bubble_sort(arr):
    n = len(arr)
    # Traverse through all array elements
    for i in range(n):
        # Last i elements are already in place
        for j in range(0, n - i - 1):
            # Traverse the array from 0 to n-i-1
            # Swap if the element found is greater
            # than the next element
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j] # Swap elements
    return arr

# Example usage:
my_list = [64, 34, 25, 12, 22, 11, 90]
print("Original list:", my_list)

sorted_list = bubble_sort(my_list.copy()) # Use a copy to keep original list unchanged
print("Sorted list:", sorted_list)

my_list_2 = [5, 1, 4, 2, 8]
print("\nOriginal list 2:", my_list_2)
sorted_list_2 = bubble_sort(my_list_2.copy())
print("Sorted list 2:", sorted_list_2)

"""### Explanation of Bubble Sort:

Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted.

Here's a breakdown of the code:

1.  **`bubble_sort(arr)` function**: Takes an array (list) `arr` as input.
2.  **Outer Loop (`for i in range(n)`)**: This loop controls the number of passes. In each pass, the largest unsorted element 'bubbles up' to its correct position at the end of the unsorted portion of the array. After `i` passes, the last `i` elements are guaranteed to be sorted.
3.  **Inner Loop (`for j in range(0, n - i - 1)`)**: This loop iterates through the unsorted portion of the array. It compares adjacent elements.
4.  **Comparison and Swap (`if arr[j] > arr[j + 1]:`)**: If the current element (`arr[j]`) is greater than the next element (`arr[j + 1]`), they are in the wrong order. The code `arr[j], arr[j + 1] = arr[j + 1], arr[j]` swaps their positions.
5.  **Return Sorted Array**: After all passes, the function returns the sorted array.
"""

def bubble_sort(arr):
    n = len(arr)
    # Traverse through all array elements
    for i in range(n):
        # Last i elements are already in place
        for j in range(0, n - i - 1):
            # Traverse the array from 0 to n-i-1
            # Swap if the element found is greater
            # than the next element
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j] # Swap elements
    return arr

# Example usage:
my_list = [64, 34, 25, 12, 22, 11, 90]
print("Original list:", my_list)

sorted_list = bubble_sort(my_list.copy()) # Use a copy to keep original list unchanged
print("Sorted list:", sorted_list)

my_list_2 = [5, 1, 4, 2, 8]
print("\nOriginal list 2:", my_list_2)
sorted_list_2 = bubble_sort(my_list_2.copy())
print("Sorted list 2:", sorted_list_2)

"""### Explanation of Bubble Sort:

Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted.

Here's a breakdown of the code:

1.  **`bubble_sort(arr)` function**: Takes an array (list) `arr` as input.
2.  **Outer Loop (`for i in range(n)`)**: This loop controls the number of passes. In each pass, the largest unsorted element 'bubbles up' to its correct position at the end of the unsorted portion of the array. After `i` passes, the last `i` elements are guaranteed to be sorted.
3.  **Inner Loop (`for j in range(0, n - i - 1)`)**: This loop iterates through the unsorted portion of the array. It compares adjacent elements.
4.  **Comparison and Swap (`if arr[j] > arr[j + 1]:`)**: If the current element (`arr[j]`) is greater than the next element (`arr[j + 1]`), they are in the wrong order. The code `arr[j], arr[j + 1] = arr[j + 1], arr[j]` swaps their positions.
5.  **Return Sorted Array**: After all passes, the function returns the sorted array.
"""

# Example using the list.sort() method (sorts in-place)
my_list_1 = [64, 34, 25, 12, 22, 11, 90]
print("Original list 1:", my_list_1)
my_list_1.sort() # Sorts the list directly
print("Sorted list 1 (using .sort()):", my_list_1)

# Example using the sorted() function (returns a new sorted list)
my_list_2 = [5, 1, 4, 2, 8]
print("\nOriginal list 2:", my_list_2)
sorted_list_2 = sorted(my_list_2) # Returns a new sorted list
print("Sorted list 2 (using sorted()):", sorted_list_2)
print("Original list 2 after sorted():", my_list_2) # Original list remains unchanged

"""### Explanation of Python's Built-in Sorting:

Python provides convenient and highly optimized built-in ways to sort lists:

1.  **`list.sort()` method**:
    *   This is a method of the list object itself (e.g., `my_list.sort()`).
    *   It **sorts the list in-place**, meaning it modifies the original list directly and does not return a new list.
    *   It returns `None`.
    *   It is generally more efficient for sorting lists you no longer need in their original order.

2.  **`sorted()` function**:
    *   This is a built-in function that can take any iterable (like a list, tuple, or string) as input (e.g., `sorted(my_list)`).
    *   It **returns a new sorted list**, leaving the original iterable unchanged.
    *   This is useful when you need to keep the original data intact and work with a sorted copy.

Both methods support optional arguments like `reverse=True` for descending order and `key` for custom sorting criteria.

### Explanation of the Code:

1.  **`import pandas as pd`**: This line imports the `pandas` library, which is excellent for working with tabular data like CSV files. We commonly alias it as `pd`.

2.  **`csv_file_path = 'your_file.csv'`**: Here, you define the name or path of your CSV file. **Remember to change `'your_file.csv'` to the actual name of your file.**

3.  **`column_to_analyze = 'your_numeric_column'`**: This sets the name of the column you want to get statistics for. **Make sure to update `'your_numeric_column'` with the exact name of a numeric column in your CSV.**

4.  **`try...except` block**: This is used for error handling. It tries to execute the code, and if certain errors (like `FileNotFoundError`) occur, it catches them and prints a helpful message instead of crashing.

5.  **`df = pd.read_csv(csv_file_path)`**: This is the core command to read your CSV file. It loads the data into a `DataFrame` object called `df`, which is like a table.

6.  **`display(df.head())`**: This prints the first 5 rows of your DataFrame, which is useful for quickly seeing what your data looks like and confirming it loaded correctly.

7.  **Column Existence and Type Check**: The code checks if the `column_to_analyze` actually exists. It then attempts to convert the column to a numeric type using `pd.to_numeric`. `errors='coerce'` means any values that *cannot* be converted to numbers will become `NaN` (Not a Number).

8.  **`df_clean = df.dropna(subset=[column_to_analyze])`**: After converting, any rows where our target column became `NaN` are removed, ensuring we only calculate statistics on valid numbers.

9.  **`mean_value = df_clean[column_to_analyze].mean()`**:
    *   `df_clean[column_to_analyze]` selects just the data from your specified column.
    *   `.mean()` then calculates the average of all the numbers in that column.

10. **`.min()` and `.max()`**: Similarly, these methods calculate the smallest and largest values in the selected numeric column.

11. **`print(...)` statements**: Finally, the code prints out the calculated mean, minimum, and maximum values, formatted to two decimal places.
"""